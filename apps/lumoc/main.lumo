type Never = ∑()

type Unit = μX. ∑(
    `Unit/unit: `Unit/unit {},
)

type Maybe = ∀T. μY. ∑(
    `Maybe/none: `Maybe/none {},
    `Maybe/some: `Maybe/some { value: T },
)

type List = ∀T. μX. ∑(
    `List/nil: `List/nil {},
    `List/cons: `List/cons { head: T, tail: X }
)

enum Bool {
    true,
    false,
}

enum Nat {
    zero,
    succ { value: Nat }
}

fn isEven(n: Nat): produce Bool {
    match unroll n {
        `Nat/zero as n => produce (roll `Bool/true {}) : Bool,
        `Nat/succ as n => v <- n.value; (force isOdd)(v),
    }
}

fn isOdd(n: Nat): produce Bool {
    match unroll n {
        `Nat/zero as n => produce (roll `Bool/false {}) : Bool,
        `Nat/succ as n => v <- n.value; (force isEven)(v),
    }
}

one <- (force isEven)(
    roll `Nat/succ { value: roll `Nat/zero {} }
);
two <- (force isEven)(
    roll `Nat/succ { value: roll `Nat/succ { value: roll `Nat/zero {} } }
);
produce ((roll `List/cons {
    head: one,
    tail: roll `List/cons {
        head: two,
        tail: roll `List/nil {}
    }
}) : List[Bool])
