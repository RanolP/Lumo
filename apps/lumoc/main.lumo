type Never = ∑()

type Unit = μX. ∑(
    `Unit/unit: `Unit/unit {},
)

type Bool = μX. ∑(
    `Bool/true: `Bool/true {},
    `Bool/false: `Bool/false {},
)

type Nat = μX. ∑(
    `Nat/zero: `Nat/zero {},
    `Nat/succ: `Nat/succ { value: X },
)


type Maybe = ∀T. μX. ∑(
    `Maybe/none: `Maybe/none {},
    `Maybe/some: `Maybe/some { value: X },
)

type List = ∀T. μX. ∑(
    `List/nil: `List/nil {},
    `List/cons: `List/cons { head: T, tail: X }
)

type Module = thunk bundle {
    `isEven: Nat -> produce Bool,
    `isOdd: Nat -> produce Bool,
}


fixpoint <- (
    fn[A](f: thunk (A -> produce A)): produce A {
        g <- produce (thunk (
            fn(x: μX. thunk (X -> produce A)): produce A {
                ret <- (force unroll x)(x);
                (force f)(ret)
            }
        ));
        (force g)(roll g)
    }
);
fixpoint_ <- fixpoint[Module];
(force fixpoint_)(thunk (fn(m: Module): produce Module {
    produce thunk bundle {
        `isEven => fn(n: Nat): produce Bool {
            match unroll n {
                `Nat/zero as n => produce (roll `Bool/true {}) : Bool,
                `Nat/succ as n => v <- n.value; ((force m) `isOdd)(v),
            }
        },
        `isOdd => fn(n: Nat): produce Bool {
            match unroll n {
                `Nat/zero as n => produce (roll `Bool/false {}) : Bool,
                `Nat/succ as n => v <- n.value; ((force m) `isEven)(v),
            }
        },
    }
}))
